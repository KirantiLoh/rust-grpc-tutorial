# Reflection
1. Perbedaannya adalah:
- Unary RPC melibatkan klien mengirimkan satu permintaan ke server dan menunggu respon tunggal dari server. Metode ini cocok digunakan ketika klien hanya perlu mengirimkan data dan mendapatkan respon tunggal dari server, seperti meminta informasi detail tentang satu entitas dari server.
- Server Streaming RPC melibatkan klien mengirimkan satu permintaan ke server, dan server merespons dengan serangkaian pesan. Metode ini cocok digunakan ketika klien membutuhkan sejumlah data dari server, tetapi server dapat mengirimkannya dalam potongan-potongan, seperti saat mengunduh file besar dari server.
- Bi-directional Streaming RPC memungkinkan klien dan server untuk saling mengirimkan serangkaian pesan secara simultan. Metode ini cocok digunakan ketika klien dan server perlu berkomunikasi secara real-time dan terus-menerus, serta mengirimkan data dalam kedua arah secara bersamaan, seperti dalam aplikasi real-time seperti chat atau game online.

2. Konsiderasinya adalah:
- Otentikasi (Authentication):
Gunakan mekanisme otentikasi yang kuat, seperti TLS (Transport Layer Security), untuk memverifikasi identitas klien dan server, mencegah serangan Man-in-the-Middle (MITM), dan memastikan keamanan komunikasi.
- Otorisasi (Authorization):
Tetapkan peran dan hak akses dengan tepat untuk setiap pengguna atau entitas yang terlibat dalam layanan gRPC, menggunakan mekanisme otorisasi yang kuat seperti RBAC (Role-Based Access Control) atau ABAC (Attribute-Based Access Control), untuk mencegah akses yang tidak sah ke sumber daya yang dilindungi.
- Enkripsi Data:
Gunakan TLS untuk mengenkripsi data yang dikirim antara klien dan server, sehingga mencegah pencurian atau manipulasi data selama transit, dan pastikan sertifikat TLS yang digunakan valid dan dikelola dengan baik untuk melindungi dari serangan sertifikat palsu.

3. Masalah yang mungkin muncul saat menangani two-way streaming di Rust gRPC adalah:
- Sinkronisasi: Memastikan bahwa klien dan server disinkronkan dengan baik saat mengirim dan menerima pesan bisa sulit, terutama saat beberapa klien terhubung ke server secara bersamaan. Ini mungkin memerlukan logika sinkronisasi tambahan untuk mengelola akses konkuren ke sumber daya bersama.
- Error handling: Menangani kesalahan dan pengecualian yang terjadi selama proses streaming bisa rumit, terutama saat berurusan dengan kode asinkron. Mungkin perlu untuk menerapkan mekanisme penanganan kesalahan dan pemulihan untuk memastikan stream ditutup dan dibersihkan dengan baik dalam kasus kesalahan.
Manajemen Sumber Daya: Mengelola sumber daya seperti memori, handle file, dan koneksi jaringan bisa menantang dengan streaming dua arah. Mungkin perlu untuk menerapkan logika manajemen sumber daya untuk memastikan alokasi dan pelepasan sumber daya yang tepat ketika diperlukan.
- Skalabilitas: Memastikan server dapat menangani banyak koneksi dan stream secara bersamaan bisa sulit, terutama dalam skenario yang membutuhkan dukungan untuk volume lalu lintas yang tinggi. Mungkin perlu untuk menerapkan penyeimbangan beban, pooling koneksi, dan fitur skalabilitas lainnya untuk menangani beban.
Kinerja: Memastikan proses streaming efisien dan performa bisa menantang, terutama dengan volume data besar atau pembaruan berfrekuensi tinggi. Meningkatkan proses streaming untuk mengurangi laten, meningkatkan throughput, dan meminimalkan penggunaan sumber daya mungkin diperlukan.
- Keamanan: Memastikan proses streaming aman dan dilindungi dari serangan.
- Reliabilitas: Memastikan proses streaming dapat diandalkan dan kuat, terutama saat koneksi jaringan mungkin tidak stabil atau tidak dapat diandalkan. Mungkin perlu untuk menerapkan logika retry, mekanisme pemulihan kesalahan, dan fitur keandalan lainnya untuk memastikan pengiriman stream berhasil.

4. Menggunakan ```tokio_stream::wrappers::ReceiverStream``` memungkinkan kita untuk mengubah ```tokio::sync::mpsc::Receiver``` menjadi ```Stream``` yang diperlukan oleh layanan gRPC. Ini berguna ketika kita ingin mengirim stream pesan dari server ke klien. Keuntungan dari menggunakan pendekatan ini adalah bahwa ini memungkinkan kita untuk dengan mudah terintegrasi dengan ekosistem tokio dan memanfaatkan fitur async/await yang kuat yang disediakan oleh tokio. Ini juga memberikan cara yang bersih untuk bekerja dengan stream di Rust. Namun, satu kerugian potensial adalah bahwa ini bisa memperkenalkan kompleksitas tambahan dan kode boilerplate, terutama bagi pengembang yang tidak akrab dengan ekosistem tokio atau pemrograman asinkron di Rust. Ini juga mungkin memerlukan penanganan kesalahan tambahan dan logika sinkronisasi untuk memastikan bahwa stream ditutup dan dibersihkan dengan baik ketika diperlukan.

5. Hal tersebut dapat dicapai dengan mengimplementasikan hal-hal berikut:
- Seperations of Concers: Bagi kode ke dalam modul atau komponen terpisah yang menangani berbagai aspek logika aplikasi. Sebagai contoh, kita dapat memiliki modul terpisah untuk penanganan autentikasi, otorisasi, validasi, penanganan kesalahan, dan logging. Ini dapat membantu meningkatkan keterbacaan kode, keberlanjutan, dan pengujian.
- Abstraksi: Gunakan abstraksi yang sesuai untuk memisahkan berbagai bagian dari kode dan mengurangi ketergantungan antara modul. Sebagai contoh, kita dapat menentukan antarmuka atau trait untuk mendefinisikan kontrak antara komponen yang berbeda dan memberikan pemisahan masalah yang jelas. Ini dapat membantu membuat kode lebih fleksibel, dapat diperluas, dan dapat digunakan kembali.
- Dependency Injection: Gunakan dependency injection untuk menyediakan dependensi ke berbagai komponen aplikasi. Ini dapat membantu memisahkan kode dan membuatnya lebih mudah untuk mengganti implementasi, melakukan mock dependensi untuk pengujian, dan mengelola siklus hidup objek. Ini dapat membantu meningkatkan keberlanjutan, pengujian, dan keleluasaan kode.
Penanganan Kesalahan: Implementasikan mekanisme penanganan kesalahan yang konsisten di seluruh basis kode untuk memastikan bahwa kesalahan ditangani dengan cara yang seragam. Ini dapat membantu meningkatkan keandalan, keberlanjutan, dan keterbacaan kode. Sebagai contoh, kita dapat menggunakan tipe Result atau Option untuk mewakili keberhasilan atau kegagalan dan menyebarluaskan kesalahan ke atas tumpukan panggilan.
- Testing: Tulis uji unit, uji integrasi, dan uji end-to-end untuk memastikan bahwa kode berperilaku sesuai yang diharapkan dan bahwa perubahan tidak memperkenalkan regresi. Ini dapat membantu menangkap bug secara dini, memastikan bahwa kode berfungsi dengan benar, dan memberikan keyakinan saat membuat perubahan pada basis kode.
- Dokumentasi: Tulis dokumentasi yang jelas dan komprehensif untuk basis kode untuk membantu pengembang lain memahami bagaimana kode bekerja, cara menggunakannya, dan cara berkontribusi padanya. Ini dapat membantu meningkatkan keberlanjutan kode, keterbacaan, dan keleluasaan seiring waktu.

6. Mengimplementasikan fitur tambahan seperti authentication & authorization, validation, dan logging dapat membuat MyPaymentService dapat memroses logika payment yang lebih kompleks.

7. gRPC memungkinkan koneksi layanan dengan cara yang lebih cepat, sederhana, fleksibel, dan juga language agnostic. Hal ini dapat memiliki dampak signifikan pada arsitektur dan desain keseluruhan sistem terdistribusi. Beberapa dampak utama dari mengadopsi gRPC sebagai protokol komunikasi meliputi:
- Interoperability: gRPC menggunakan Protocol Buffers sebagai bahasa definisi interface, yang menyediakan cara yang language agnostic untuk mendefinisikan struktur pesan dan layanan. Ini dapat membantu meningkatkan interoperabilitas antara layanan yang ditulis dalam bahasa pemrograman yang berbeda dan berjalan di platform yang berbeda. Sebagai contoh, sebuah layanan yang ditulis dalam Rust dapat dengan mudah berkomunikasi dengan layanan yang ditulis dalam Go atau Java menggunakan gRPC.
- Kinerja: gRPC menggunakan HTTP/2 sebagai protokol dasar, yang menawarkan beberapa peningkatan kinerja dibandingkan HTTP/1.1. Ini dapat menghasilkan komunikasi yang lebih cepat dan efisien antara layanan, terutama dalam skenario di mana beberapa permintaan perlu dikirim secara paralel atau di mana laten rendah sangat penting.

8. Beberapa kelebihan dari HTTP/2 adalah:
- Multiplexing: HTTP/2 mendukung multiplexing, memungkinkan beberapa request dan response dikirim dan diterima secara paralel melalui satu koneksi. Ini dapat meningkatkan kinerja dan mengurangi latency, terutama untuk aplikasi yang melakukan beberapa permintaan ke server.
- Kompresi Header: HTTP/2 menggunakan kompresi header untuk mengurangi ukuran header HTTP, yang dapat menghasilkan pengurangan overhead jaringan dan peningkatan kinerja.
- Server Push: HTTP/2 mendukung server push, memungkinkan server untuk mengirim sumber daya tambahan ke klien sebelum mereka diminta. Ini dapat membantu meningkatkan kinerja dengan mengurangi jumlah perjalanan yang diperlukan untuk mengambil sumber daya.
- Protokol Binari: HTTP/2 menggunakan protokol biner, yang dapat lebih efisien daripada protokol berbasis teks yang digunakan oleh HTTP/1.1. Ini dapat menghasilkan kinerja yang lebih baik dan mengurangi overhead jaringan.

9. Dalam REST API, klien mengirimkan request ke server dan menunggu response dari server. Komunikasi ini bersifat request-response dan klien tidak bisa menerima data dari server sampai ia mengirimkan request lain. Model ini cocok untuk interaksi sederhana dan stateless di mana klien perlu mengambil atau update data pada server. Namun, model ini tidak cocok untuk komunikasi real-time atau skenario di mana server perlu mengirim pembaruan terus-menerus ke klien. gRPC, di sisi lain, mendukung bidirectional streaming, di mana baik klien maupun server dapat mengirim stream pesan satu sama lain. Ini memungkinkan komunikasi real-time dan interaktif antara klien dan server, membuatnya cocok untuk skenario seperti chat app, multiplayer, atau situasi apa pun di mana kedua belah pihak perlu mengirim dan menerima data secara asinkron. Kemampuan streaming dua arah ini dari gRPC memungkinkan komunikasi yang lebih responsif dan interaktif dibandingkan dengan model request-response dari REST API.

10. Sifat schema-based dari gRPC menggunakan Protocol Buffers memiliki beberapa keunggulan dibandingkan dengan sifat yang lebih fleksibel, tanpa skema dari JSON dalam muatan API REST. Protocol Buffers menyediakan skema yang jelas dan terdefinisi dengan baik untuk mendefinisikan struktur pesan, yang dapat membantu memastikan konsistensi dan kompatibilitas antara layanan dan platform yang berbeda. Ini dapat sangat berguna dalam sistem yang besar dan terdistribusi di mana beberapa layanan perlu berkomunikasi satu sama lain. Protocol Buffers juga menyediakan tipe dan validasi yang kuat, yang dapat membantu mendeteksi kesalahan lebih awal dan mengurangi risiko kesalahan saat runtime. Selain itu, Protocol Buffers lebih efisien dalam hal serialisasi dan deserialisasi dibandingkan dengan JSON, yang dapat menghasilkan kinerja yang lebih baik dan mengurangi overhead jaringan. Namun, sifat berbasis skema dari Protocol Buffers juga dapat lebih membatasi dan kurang fleksibel dibandingkan dengan JSON, yang mungkin membuatnya lebih sulit untuk mengembangkan API dari waktu ke waktu atau bekerja dengan struktur data dinamis. JSON, di sisi lain, lebih fleksibel dan lebih mudah digunakan untuk interaksi sederhana, namun kurang memiliki tipe dan validasi yang kuat yang disediakan oleh Protocol Buffers.